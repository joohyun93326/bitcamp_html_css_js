<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Insert title here</title>
	<script type="text/javascript">
	/* 
	​
	자바 설계도(클래스) => 재사용성
	class Product{
	private String carname="pony";
	public Product(){}
	public Product(String carname){
	this.carname= carname;
	}
	public void print(){
	System.out.println(this.carname);
	}
	}
	​
	메모리 load ... (new)
	Product p = new Product();
	Product p2 = new Product("pony2");
	​
	p.print();
	p2.print();
	/////////////////////////////////////////////////////
	​
	javaScript >> 객체지향언어(OOP)
	​
	클래스 정의 3가지 방법
	1. 프로토타입 방식 : 일반적인 클래스 제작 방법
	인스턴스마다 공통된 메서드를 공유해서 사용하는 장점 
	Jquery 도 prototype 방식으로 설계
	​
	function 클래스이름() {
	this.프로퍼티1 = 초기값;
	this.프로퍼티2 = 초기값;
	}
	​
	클래스이름.prototype.메서드1 = function() {
	​
	}
	​
	클래스이름.prototype.메서드2 = function() {
	​
	}
	var 인스턴스 = new 클래스이름(); 
	var carObj = new Car();
	var carObj2 = new Car();
	var carObj3 = new Car();
	​
	​
	2. 함수 방식 : 간단한 클래스 제작 시 사용 
	인스턴스마다 메서드가 독립적으로 만들어지는 단점
	
	** 클래스 : function Car(){ this.name = , this.age=}
	** 함수 : function car(){}
	
	function 클래스이름() {
			this.프로퍼티1 = 초기값;
			this.프로퍼티2 = 초기값;
	​		this.메서드1 = function() {
			}
			this.메서드2 = function() {
			}
	​}
	
	var 인스턴스 = new 클래스이름(); 
	var carObj = new Car();
	var carObj2 = new Car();
	var carObj3 = new Car();
	​
	​*****
	3. 리터럴 방식 : 클래스 만드는 용도는 아니며 주로 여러개의 매개변수를 그룹으로 묶어 함수의 매개변수로 보낼때
	정의와 함께 인스턴스가 만들어지는 장점이 있음 단 인스턴스는 오직 하나
	(초보자에게도 중요 ^^)
	
	​
	4. ECMA6 버전부터 : class 키워드 제공
	class Person {
				constructor(name) {
				this._name = name;
				}
				sayHi() {
					console.log(`Hi! ${this._name}`);
				}
	}
	​
	[ javascript 객체 생성 ]
	​
	1.오브젝트 리터럴 방식 (객체를 만드는 방법): 클래스 생성과 동시에 객체가 만들어 져요
	1.1 리터럴 방식 >> 제일 간단한 방법 > var obj = {}; //var objarr = [] 배열 
	1.2 JSON 표기 : {} >> JSON: JavaScript Object Notation
	​
	ex) var myObj = { "name":"John", "age":31, "city":"New York" };
	TIP) JSON >> XML (텍스트 기반의 형식화된 문서 제공)
	XML :이기종간의 데이터 호환 (한 때는 서점 : xml webservice)
	
	​
	다른 이야기 >> JSON
	객체지향언어 장점 : 설계도 (재사용성)
	*오브젝트 리터럴 방식 : 재사용을 지원하는 않는다 (만들고, 쓰고, 버린다)
	*설계도를 생성과 동시에 객체 생성(장점 : 편하고 , 빠르다 )
	*설계도를 미리 만들어 놓고 재사용하는 방식은 아니다
	*설계도당 하나의 객체만 생성 사용 (only object)
	​
	​
	var product = {}; //Product p = new Product();
	var product2 = {제품명:'사과',년도:'2018',원산지:'대구'};
	var 인스턴스 ={
				프로퍼티:초기값,
				프로퍼티:초기값,
				.....	
				메서드:function(){},
				메서드:function(){}....
	}
	​
	리터럴 방식 > 선언과 동시에 인스턴스 자동 생성
	var 인스턴스 = {}
	특징 : 생성자 존재하지 않는다.
	프로퍼티(변수)와 메서드(함수)만 정의 가능
	단점 : 객체 하나 생성(재사용성 없다) 
	접근방법 : 인스턴스이름.자원 >> product2.제품명 
	*/
	
	let product = {제품명:'사과' , 년도:'2000', 원산지:'대구'};
	
	console.log(product); //{제품명: "사과", 년도: "2000", 원산지: "대구"}
	document.write(product.제품명 +"<br>"); //사과 
	document.write(product.년도 +"<br>"); //2000
	document.write(product.원산지 +"<br>"); //대구 
	
	//{객체}
	let person = {
			name: "홍길동" ,
			addr: "서울시 강남구 역삼동" ,
			eat:function(food) {
				document.write(this.name + "/" + this.addr + "/" + food + "냠냠")
				}
	};
	
	document.write("<hr>");
	person.eat("사과"); //person클래스 eat 함수에 parameter 값 전달 
	
	//1.속성 제거 기능 (delete)
	delete(product.년도);
	console.log(product); //년도를 삭제했으니 {제품명: "사과", 원산지: "대구"}
	
	for(let key in product) {
		console.log("key :" +key); //key는 변수명 {key :제품명, key :원산지}
		console.log(product[key]); //key를 던지고 value를 받아옴 {사과, 대구}
	}
	document.write("<hr>");
	
	for(let key in person){
		console.log("key :" + key + "=" + person[key]); //person에 key를 던지고 value를 받아옴 
	}
	/* key :name=홍길동
	key :addr=서울시 강남구 역삼동
	key :eat=function(food) {
		document.write(this.name + "/" + this.addr + "/" + food + "냠냠")
		} */
		
	//json 객체 활용 (xml)
	//외부 API 제공 (제공 데이터 : xml  or json : 서울시 공공데이터 , 대법원 판례 , 날씨 정보 )
	//KEY POINT : 제공 받은 xml or json 객체를 원하는 데이터만 추출해서 화면 출력 
	//2차 프로젝트 강제사항 최소 2개 이상 (외부 API)
	
	let Member={}; //빈 객체 
	Member.name = "hong"; //{name:"hong"} 속성 추가 
	console.log(Member); //{name: "hong"}
	console.log(Member.name); //hong
	
	Member.age = 100;
	
	//기능(함수)
	Member.print = function() {
		document.write("<br>" + this.name + "/" + this.age + "<br>");
	}
	
	Member.print(); //hong/100
	
	//POINT : 객체가 객체를 가질 수 있다, 객체가 배열을 가질 수 있다//
	//java : class Member {Car car; ArrayList list;}
	
	let Grade = {
			 list:{
				 		"hong":10,
				 		"kim" :20,
				 		"park":30
			 		},
			 show:function(){
				 for(let key in this.list){
					document.write(key + " : " + this.list[key] + "<br>"); 
				 }
			 }		
	 }
	 
	 Grade.show();
	 document.write("<hr>");
	 
	 let listobj = Grade.list;  
	 console.log(Grade.list); //{hong: 10, kim: 20, park: 30}
	 console.log(listobj); //{hong: 10, kim: 20, park: 30}
		
	 document.write(listobj.kim); //20 
	 document.write("<br>"); 
	 
	 for(let key in listobj){
		 document.write(key + " : " + listobj[key] + "<br>");
	 }
	 //hong : 10
	 //kim : 20
	 //park : 30
		
	</script>
</head>
<body>
	

</body>
</html>


